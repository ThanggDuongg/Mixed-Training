# Expression Tree

## Why need use Expression to wrap Func in CSharp

Using __`Expression`__ to wrap a __`Func`__ in C# can be useful when you need to dynamically create and compile expressions that represent code, rather than simply invoking a delegate. The __`Expression`__ class provides a way to build, manipulate, and compile expressions as code, rather than just executing a delegate. This can be useful in various scenarios, such as:

Creating expression trees: Expression trees allow you to represent code as data, which can be used for purposes such as LINQ to SQL and Entity Framework, where you can generate code based on an expression tree rather than a delegate.

Dynamic method invocation: You can use expression trees to create and compile a method at runtime, which can be useful when you need to dynamically create methods based on runtime data.

Debugging: Expression trees can be decompiled into source code, which can be useful when debugging dynamic code.

Performance optimization: You can use expression trees to optimize code by manually creating expressions that are more efficient than the code generated by the C# compiler.

In short, __`Expression`__ provides a way to dynamically create, manipulate, and compile code, while __`Func`__ provides a way to execute a delegate. Using __`Expression`__ can be useful in situations where you need to dynamically generate code, while __`Func`__ is useful for simple delegate invocation.

## Vietnamese

Sử dụng __`Expression`__ bọc __`Func`__ có một số lợi ích so với chỉ sử dụng __`Func`__:

- Tối ưu hoá truy vấn: Sử dụng __`Expression`__ cho phép bạn biểu diễn các truy vấn LINQ dưới dạng các biểu thức cụ thể, đồng thời có thể tối ưu hoá truy vấn từ cơ sở dữ liệu.

- Tạo mã độc lập: Sử dụng __`Expression`__ cho phép bạn tạo các truy vấn mà không phụ thuộc vào cơ sở dữ liệu cụ thể, giúp tạo mã độc lập và dễ dàng chuyển đổi giữa các nguồn dữ liệu khác nhau.

- Tạo mã tái sử dụng: Sử dụng __`Expression`__ cho phép bạn tạo các truy vấn mà có thể tái sử dụng, giúp giảm số lượng mã cần viết và dễ dàng quản lý.

Tuy nhiên, sử dụng __`Expression`__ cũng có một số hạn chế, như mã tốc độ chậm hơn so với __`Func`__, và mã khó hiểu hơn do sử dụng các biểu thức phức tạp. Do đó, sử dụng Expression hay __`Func`__ tùy thuộc vào nhu cầu cụ thể của bạn.

## Example

```cs
Func<Dish, bool> f = d => d.Title.StartsWith("F");
Expression<Func<Dish, bool>> ex = d => d.Title.StartsWith("F");
```

Cả hai hàm `Func<Dish, bool> f` và `Expression<Func<Dish, bool>> ex` đều là một delegate trong C#. Tuy nhiên, có một số sự khác biệt giữa hai hàm này:

- Kiểu dữ liệu: `Func<Dish, bool> f` là một delegate cụ thể, trong khi `Expression<Func<Dish, bool>> ex` là một biểu thức delegate.

- Sử dụng: `Func<Dish, bool> f` có thể được sử dụng để tạo một delegate để gọi một hàm có thể tính toán, trong khi `Expression<Func<Dish, bool>> ex` có thể được sử dụng để tạo ra một biểu thức delegate để xác định một biểu thức tính toán, hoặc có thể được chuyển hóa thành một delegate.

- Khả năng mở rộng: `Expression<Func<Dish, bool>> ex` có thể được sử dụng để tạo ra các biểu thức delegate mở rộng, trong khi `Func<Dish, bool> f` không có tính năng này.

Vì vậy, trong một số trường hợp, sử dụng `Expression<Func<Dish, bool>> ex` có thể cung cấp nhiều tính năng và tính mở rộng hơn so với sử dụng `Func<Dish, bool> f`.

---

`Func<Dish, bool> f` là một delegate trong C#, đại diện cho một hàm có kiểu trả về là `bool` và nhận một tham số có kiểu `Dish`. Khi chạy chương trình, `f` được coi như một phương thức, vì nó đại diện cho một hàm có thể được gọi và có thể tính toán.

Ví dụ, ta có thể gọi `f` như sau:

```cs
Func<Dish, bool> f = d => d.Title.StartsWith("F");

Dish dish = new Dish();
dish.Title = "Fried Rice";

bool result = f(dish);
```

Trong ví dụ này, `f` được gọi với một đối tượng `dish` như là tham số, và trả về một giá trị `bool`.

---

EFCore có thể sử dụng `Func<Dish, bool>` để tìm kiếm và lọc dữ liệu trong một bảng cơ sở dữ liệu. Tuy nhiên, EFCore thích hơn `Expression<Func<Dish, bool>>` vì nó có thể phân tích biểu thức và __chuyển nó thành câu lệnh SQL__, hoặc tối ưu hóa biểu thức theo cách khác.

Ví dụ, ta có thể sử dụng `Expression<Func<Dish, bool>>` như sau để tìm kiếm các món ăn có tiêu đề bắt đầu bằng ký tự "F" trong một bảng cơ sở dữ liệu:

```cs
Expression<Func<Dish, bool>> ex = d => d.Title.StartsWith("F");
var dishes = _context.Dishes.Where(ex).ToList();
```

Trong ví dụ này, EFCore sẽ sử dụng biểu thức `ex` để tìm kiếm các món ăn trong bảng cơ sở dữ liệu, và trả về một danh sách các món ăn thỏa mãn yêu cầu. 

## Dynamic query with Expression Trees

Dynamic query với Expression trees là một kỹ thuật cho phép tạo các truy vấn tùy chỉnh dựa trên các điều kiện được cung cấp tại thời điểm chạy chương trình. Điều này có nghĩa là chúng ta có thể tạo các truy vấn mà các điều kiện tìm kiếm được chỉ định tại thời điểm chạy chương trình, không phải tại thời điểm viết mã.

```cs
var d = Expression.Parameter(typeof(Dish), "d");
var sw = typeof(string).GetMethod(nameof(string.StartsWith), new[] { typeof(string) });

ex = Expression.Lambda<Func<Dish, bool>>(
    Expression.Call(
        Expression.Property(d, nameof(Dish.Title)),
        sw!,
        Expression.Constant("F")), 
    d);
```
